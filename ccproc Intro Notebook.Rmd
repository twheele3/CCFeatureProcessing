---
title: "CCProcessing Primer"
output: html_notebook
---

##1) Load library and set working directory.

```{r setup}
library(ccproc)

wd <- dirname(rstudioapi::getActiveDocumentContext()$path)
knitr::opts_chunk$set(root.dir = dirname(rstudioapi::getActiveDocumentContext()$path))

```

##2) Set data directory and load file list.

```{r set_directory}
datadir <- "G:/Zeiss Confocal/Cellcounter Aggregation/cellcounter/New/"
filenames <- list.files(datadir)
files <- paste0(datadir,filenames)
```

##3) Load files into a new CellCounterDB object.

```{r load_files}
ccdb <- CellCounterDB$new(files)
```

##4) Process raw data into features (crypts)

```{r feature_processing}
ccdb$processFeatures()
```

##5) Tag attributes based on filenames.

```{r tag_attributes}
ccdb$tag_attribute(Regex="(TW[0-9]{2})",attribute="Sample")
```

##6) Verify feature detection with debug plots.

```{r debug_plots}
for(i in levels(ccdb$cells$Image)){
  ccdb$plot_debug(i,savedir="G:/Zeiss Confocal/Cellcounter Aggregation/test/")
  graphics.off()
}
```

##7) Save database object to file.

```{r save_db}
ccdb$save(file="ccdb")
```

##8) Call cells from specific rows, according to specific features.

```{r calling_data}
index <- ccdb$which_cells(list("Sample" = "TW28", "Pos.Crypt" = 0:10, "Reg4-dsRed" = TRUE))
print(ccdb$cells[index,])
```


Adding functions to privately plot debugs amongst ones that need it. 
```{r more_debugging}
ccdb$metadata$run_debug <- TRUE
ccdb$metadata$debug_dir <- "G:/Zeiss Confocal/Cellcounter Aggregation/debug/"

to_debug <- c("IHC009 TW30-4R EphrinB1 005.lsm",
              "IHC009 TW30-6L Villin 005.lsm",
              "IHC009 TW30-7R ChgA 001.lsm",
              "TW21-29 IHC005 p-Histone3 5.czi")
ccdb$processFeatures(ccnames=to_debug)

ccdb$metadata$run_debug <- FALSE
```




```{r sandbox}
angle = function(x,y){
      # Calcs angle between two vectors in radians, nondirectional max value pi. Assumes origin of 0^n
      dot.prod <- x%*%y
      norm.x <- base::norm(x,type="2")
      norm.y <- base::norm(y,type="2")
      theta <- acos(dot.prod / (norm.x * norm.y))
      return(as.numeric(theta))
    }

    twolines_angle = function(a,b,c,d){
      # Finds the angle between two lines AB and CD
      # Assumes that all connect A-B-C-D, with B and C serving as origins for A and D.
      x <- NaN
      try(x <- angle(a-b,d-c),silent=TRUE)
      if(is.nan(x)){return(pi)}
      else(return(x))
    }

    rolling_angle = function(v,cc){
      # tryCatch({
        return(mapply(function(x1,y1,x2,y2,x3,y3,x4,y4){twolines_angle(c(x1,y1),c(x2,y2),c(x3,y3),c(x4,y4))},
                      x1 = cc$cells[v[c(1,1:(length(v)-1))],c("X")],
                      y1 = cc$cells[v[c(1,1:(length(v)-1))],c("Y")],
                      x2 = cc$cells[v[c(1:length(v))],c("X")],
                      y2 = cc$cells[v[c(1:length(v))],c("Y")],
                      x3 = cc$cells[v[c(2:length(v),length(v)+1)],c("X")],
                      y3 = cc$cells[v[c(2:length(v),length(v)+1)],c("Y")],
                      x4 = cc$cells[v[c(3:length(v),length(v)+1,length(v)+2)],c("X")],
                      y4 = cc$cells[v[c(3:length(v),length(v)+1,length(v)+2)],c("Y")]))
      # },
        # Including error/warning functions to send back vector of 1s on assumption that supplied v is too short to work.
        # error = function(e){return(rep(1,times=length(v)))},
        # warning = function(w){return(rep(1,times=length(v)))})
    }
    
cc <- ccdb$CCFiles$`ABT01 IHC006 TW28-13 Dll4 1-400 1.czi`

v <- ccdb$cells$Index[1:30]

rolling_angle(v,cc)

```

