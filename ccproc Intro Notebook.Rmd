---
title: "CCProcessing Primer"
output: html_notebook
---

##1) Load library and set working directory.

```{r setup}
library(ccproc)

wd <- dirname(rstudioapi::getActiveDocumentContext()$path)
knitr::opts_chunk$set(root.dir = dirname(rstudioapi::getActiveDocumentContext()$path))

```

##2) Set data directory and load file list.

```{r set_directory}
datadir <- "G:/Zeiss Confocal/Cellcounter Aggregation/cellcounter/New/"
filenames <- list.files(datadir)
files <- paste0(datadir,filenames)
```

##3) Load files into a new CellCounterDB object.

```{r load_files}
ccdb <- CellCounterDB$new(files)
```

##3A) Remove duplicate cell marks.

```{r remove_duplicates}
ccdb$remove_duplicates()
```


##4) Process raw data into features (crypts)

```{r feature_processing}
ccdb$processFeatures()
```

##5) Tag attributes based on filenames.

```{r tag_attributes}
ccdb$tag_attribute( Regex = "(TW[0-9]{2})", attribute = "Sample" )
```

##6) Verify feature detection with debug plots.

```{r debug_plots}
ccdb$plot_debug( names(ccdb$CCFiles), savedir = "G:/Zeiss Confocal/Cellcounter Aggregation/test/" )
```

##7) Save database object to file.

```{r save_db}
ccdb$save(file="ccdb")
```

##8) Call cells from specific rows, according to specific features.

```{r calling_data}
index <- ccdb$which_cells(list("Sample" = "TW28", "Pos.Crypt" = 0:10, "Reg4-dsRed" = TRUE))
print(ccdb$cells[index,])
```


Adding functions to privately plot debugs amongst ones that need it. 
```{r more_debugging}
ccdb$metadata$run_debug <- TRUE
ccdb$metadata$debug_dir <- "G:/Zeiss Confocal/Cellcounter Aggregation/debug/"

to_debug <- c("IHC009 TW30-4R EphrinB1 005.lsm",
              "IHC009 TW30-6L Villin 005.lsm",
              "IHC009 TW30-7R ChgA 001.lsm",
              "TW21-29 IHC005 p-Histone3 5.czi")
ccdb$processFeatures(ccnames=to_debug)

ccdb$metadata$run_debug <- FALSE
```




```{r sandbox}
for(img in names(self$CCFiles)){
  # Radius given in pixels and converted to real distance based on calibration. 
  radius <- 35
  radius = radius * as.numeric(levels(self$CCFiles[[img]]$metadata$X_Calibration)[1])
  
  # Calculate pairs that are closer than stated radius.
  indices <- which(as.matrix(stats::dist(self$CCFiles[[img]]$cells[,c("X","Y","Z")])) <= radius, arr.ind=TRUE)
  if(length(indices) > 0){
    indices = indices[indices[,1] > indices[,2],]
  }
  
  i <- length(indices)/2
  # Proceed if any are close enough.
  # Iterative process to remove clusters then check whether there are any still too close. 
  while(length(indices)>0){
    merged <- t(data.frame(lapply(1:(length(indices)/2), function(x){
      c(colMeans(self$CCFiles[[img]]$cells[c(indices[c(x,x+(length(indices)/2))]),!(colnames(self$CCFiles[[img]]$cells) %in% self$CCFiles[[img]]$metadata$Markers)]),
        colSums( self$CCFiles[[img]]$cells[c(indices[c(x,x+(length(indices)/2))]),self$CCFiles[[img]]$metadata$Markers]) > 0)
    })))
    
    self$CCFiles[[img]]$cells = rbind(self$CCFiles[[img]]$cells[-unique(c(indices)),],merged)
    rownames(cc) <- NULL 
    indices = which(as.matrix(stats::dist(self$CCFiles[[img]]$cells[,c("X","Y","Z")])) <= radius, arr.ind=TRUE)
    if(length(indices)>0){
      indices = indices[indices[,1] > indices[,2],]
    }
    i = i + length(indices)/2
  }
  if(i > 0){
    # Set markers back to boolean
    self$CCFiles[[img]]$cells[,self$CCFiles[[img]]$metadata$Markers] <- self$CCFiles[[img]]$cells[,self$CCFiles[[img]]$metadata$Markers] > 0
    # Remove old cells from database.
    self$cells = self$cells[!(self$cells$Image==img),]
    # Insert new cells.
    plyr::rbind.fill(self$cells,self$CCFiles[[img]]$cells)
    # Alert that some duplicates detected.
    message(paste(i,"duplicate cells merged in",img))
  } 
}
```

# New testline
